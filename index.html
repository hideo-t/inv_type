<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>INVADER TYPE - 行動分析システム</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0a0a0a;
            font-family: 'Press Start 2P', monospace;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            color: #00ff00;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        .crt-container {
            position: relative;
            width: 90vw;
            max-width: 800px;
            height: 90vh;
            max-height: 700px;
            background: #000;
            border: 15px solid #2a2a2a;
            border-radius: 8px;
            box-shadow: 
                0 0 50px rgba(0, 255, 0, 0.3),
                inset 0 0 50px rgba(0, 255, 0, 0.05);
            overflow: hidden;
        }
        
        .crt-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.15),
                rgba(0, 0, 0, 0.15) 1px,
                transparent 1px,
                transparent 2px
            );
            pointer-events: none;
            z-index: 1000;
            animation: scanline 8s linear infinite;
        }
        
        .crt-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(0, 0, 0, 0.3) 100%);
            pointer-events: none;
            z-index: 999;
        }
        
        @keyframes scanline {
            0% { transform: translateY(0); }
            100% { transform: translateY(10px); }
        }
        
        canvas {
            display: block;
            background: #000;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        
        .game-ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 20px;
            z-index: 100;
            pointer-events: none;
        }
        
        .score-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            text-shadow: 0 0 10px #00ff00;
        }
        
        .start-screen, .game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.9);
            z-index: 200;
            text-align: center;
            padding: 20px;
        }
        
        .start-screen h1, .game-over-screen h1 {
            font-size: 24px;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #00ff00;
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .instructions {
            font-size: 10px;
            line-height: 1.8;
            margin-bottom: 30px;
            max-width: 500px;
        }
        
        .start-button, .retry-button {
            background: transparent;
            border: 2px solid #00ff00;
            color: #00ff00;
            padding: 15px 30px;
            font-family: 'Press Start 2P', monospace;
            font-size: 12px;
            cursor: pointer;
            pointer-events: all;
            transition: all 0.3s;
            text-shadow: 0 0 10px #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        
        .start-button:hover, .retry-button:hover {
            background: #00ff00;
            color: #000;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.6);
        }
        
        .hidden {
            display: none !important;
        }
        
        .lives {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .life-icon {
            width: 20px;
            height: 12px;
            background: #00ff00;
            clip-path: polygon(50% 0%, 0% 100%, 100% 100%);
        }
        
        .live-metrics {
            position: absolute;
            top: 60px;
            right: 20px;
            font-size: 8px;
            line-height: 2;
            text-shadow: 0 0 10px #00ff00;
            z-index: 100;
            pointer-events: none;
            display: block; /* デバッグ: 常に表示 */
            background: rgba(0, 0, 0, 0.8); /* 背景追加で見やすく */
            padding: 10px;
            border: 1px solid #00ff00;
        }
        
        .live-metrics.active {
            display: block;
        }
        
        .metric-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .metric-label {
            width: 50px;
        }
        
        .metric-bar {
            width: 60px;
            height: 8px;
            background: #001100;
            border: 1px solid #003300;
            position: relative;
        }
        
        .metric-fill {
            height: 100%;
            transition: width 0.3s ease, background-color 0.3s ease;
        }
        
        .metric-value {
            width: 40px;
            text-align: right;
        }
        
        .danger-low { background: #00ff00; }
        .danger-medium { background: #ffff00; }
        .danger-high { background: #ff0000; }
        
        .mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            display: none;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            z-index: 150;
        }
        
        @media (max-width: 600px) {
            .mobile-controls {
                display: flex;
            }
            .live-metrics {
                top: 45px;
                right: 10px;
                font-size: 6px;
            }
            .metric-label {
                width: 30px;
            }
            .metric-bar {
                width: 40px;
                height: 6px;
            }
            .metric-value {
                width: 30px;
                font-size: 6px;
            }
        }
        
        .control-btn {
            width: 60px;
            height: 60px;
            background: rgba(0, 255, 0, 0.2);
            border: 2px solid #00ff00;
            border-radius: 8px;
            color: #00ff00;
            font-size: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            user-select: none;
            touch-action: manipulation;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
        }
        
        .control-btn:active {
            background: rgba(0, 255, 0, 0.4);
            transform: scale(0.95);
        }
        
        .fire-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            font-size: 10px;
        }
        
        .direction-controls {
            display: flex;
            gap: 10px;
        }
        
        @media (min-width: 601px) {
            .mobile-only {
                display: none;
            }
        }
        
        @media (max-width: 600px) {
            .desktop-only {
                display: none;
            }
            .start-screen h1, .game-over-screen h1 {
                font-size: 18px;
            }
            .instructions {
                font-size: 8px;
            }
            .start-button, .retry-button {
                font-size: 10px;
                padding: 12px 24px;
            }
        }
        
        .result-container {
            max-width: 600px;
            width: 90%;
            max-height: 70vh;
            overflow-y: auto;
            padding: 20px;
            background: rgba(0, 20, 0, 0.8);
            border: 2px solid #00ff00;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.4);
        }
        
        .rare-title {
            font-size: 16px;
            color: #ffff00;
            text-shadow: 0 0 20px #ffff00;
            margin-bottom: 15px;
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .main-title {
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        .tagline {
            font-size: 9px;
            color: #00cc00;
            margin-bottom: 20px;
            line-height: 1.6;
        }
        
        .mini-titles {
            font-size: 8px;
            margin-bottom: 20px;
            line-height: 1.8;
        }
        
        .comments {
            font-size: 8px;
            line-height: 1.8;
            color: #00aa00;
            margin-bottom: 20px;
            border-top: 1px solid #004400;
            padding-top: 15px;
        }
        
        .metrics {
            font-size: 7px;
            color: #008800;
            line-height: 1.6;
        }
    </style>
</head>
<body>
    <div class="crt-container">
        <canvas id="gameCanvas"></canvas>
        
        <div class="game-ui">
            <div class="score-panel">
                <div>SCORE: <span id="score">0000</span></div>
                <div>HI-SCORE: <span id="hiScore">0000</span></div>
                <div class="lives">
                    LIVES: 
                    <div id="livesContainer"></div>
                </div>
            </div>
        </div>
        
        <div class="live-metrics" id="liveMetrics">
            <div class="metric-row">
                <div class="metric-label">ATTACK</div>
                <div class="metric-bar">
                    <div class="metric-fill" id="attackBar" style="width: 0%; background: #00ff00;"></div>
                </div>
                <div class="metric-value" id="attackValue">0.0</div>
            </div>
            <div class="metric-row">
                <div class="metric-label">DANGER</div>
                <div class="metric-bar">
                    <div class="metric-fill danger-low" id="dangerBar" style="width: 0%;"></div>
                </div>
                <div class="metric-value" id="dangerValue">0%</div>
            </div>
            <div class="metric-row">
                <div class="metric-label">PRECIS</div>
                <div class="metric-bar">
                    <div class="metric-fill" id="precisionBar" style="width: 0%; background: #00ff00;"></div>
                </div>
                <div class="metric-value" id="precisionValue">--</div>
            </div>
        </div>
        
        <div class="start-screen" id="startScreen">
            <h1>INVADER<br>ANALYZER</h1>
            <div class="instructions">
                <span class="desktop-only">← → : 移動<br>SPACE : 発射</span>
                <span class="mobile-only">画面下のボタンで操作</span>
                <br><br>
                インベーダーを倒して<br>
                あなたの行動パターンを<br>
                分析します！<br>
                <br>
                <span style="font-size: 8px; color: #00aa00;">
                プレイスタイルから<br>
                専用称号を生成
                </span>
            </div>
            <button class="start-button" id="startButton">START ANALYSIS</button>
        </div>
        
        <div class="game-over-screen hidden" id="gameOverScreen">
            <h1>ANALYSIS COMPLETE</h1>
            <div class="instructions">
                FINAL SCORE: <span id="finalScore">0000</span>
            </div>
            <div class="result-container" id="resultContainer">
            </div>
            <button class="retry-button" id="retryButton" style="margin-top: 20px;">RETRY</button>
        </div>
        
        <div class="mobile-controls">
            <div class="direction-controls">
                <div class="control-btn" id="leftBtn">◀</div>
                <div class="control-btn" id="rightBtn">▶</div>
            </div>
            <div class="control-btn fire-btn" id="fireBtn">FIRE</div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startButton = document.getElementById('startButton');
        const retryButton = document.getElementById('retryButton');
        const scoreEl = document.getElementById('score');
        const hiScoreEl = document.getElementById('hiScore');
        const finalScoreEl = document.getElementById('finalScore');
        const livesContainer = document.getElementById('livesContainer');
        const resultContainer = document.getElementById('resultContainer');
        
        // 効果音（ユーザーインタラクション後に初期化）
        let audioContext = null;
        
        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        
        // ===== トラッカー =====
        const tracker = {
            tStart: 0,
            tEnd: 0,
            shots: 0,
            hits: 0,
            kills: 0,
            moveDist: 0,
            turns: 0,
            dangerTime: 0,
            lifeLost: 0,
            lastHitAt: -Infinity,
            postHitWindowMs: 2500,
            postHitShots: 0,
            postHitMove: 0,
            lastX: null,
            lastMoveDir: 0,
            
            // リアルタイム指標用（直近3秒）
            recentShots: [],      // [{time, hit}]
            recentDanger: [],     // [{time, danger}]
            windowMs: 3000,
            
            start(now, playerX) {
                this.tStart = now;
                this.lastX = playerX;
                this.recentShots = [];
                this.recentDanger = [];
            },
            
            end(now) {
                this.tEnd = now;
            },
            
            onShoot(now, hit = false) {
                this.shots++;
                this.recentShots.push({ time: now, hit: hit });
                console.log('Shot recorded:', { time: now, hit: hit, total: this.recentShots.length });
                if (now - this.lastHitAt <= this.postHitWindowMs) this.postHitShots++;
            },
            
            onHitEnemy() {
                this.hits++;
            },
            
            onKillEnemy() {
                this.kills++;
            },
            
            onLifeLost(now) {
                this.lifeLost++;
                this.lastHitAt = now;
                this.postHitShots = 0;
                this.postHitMove = 0;
            },
            
            update(now, dtMs, playerX, dangerFlag) {
                if (this.lastX != null) {
                    const dx = Math.abs(playerX - this.lastX);
                    this.moveDist += dx;
                    if (now - this.lastHitAt <= this.postHitWindowMs) this.postHitMove += dx;
                    
                    const dir = (playerX > this.lastX) ? 1 : (playerX < this.lastX ? -1 : 0);
                    if (dir !== 0 && this.lastMoveDir !== 0 && dir !== this.lastMoveDir) {
                        this.turns++;
                    }
                    if (dir !== 0) this.lastMoveDir = dir;
                    
                    this.lastX = playerX;
                }
                
                if (dangerFlag) this.dangerTime += dtMs;
                
                // リアルタイム危険度記録
                this.recentDanger.push({ time: now, danger: dangerFlag ? dtMs : 0 });
                
                // 古いデータを削除（3秒以上前）
                const cutoff = now - this.windowMs;
                this.recentShots = this.recentShots.filter(s => s.time > cutoff);
                this.recentDanger = this.recentDanger.filter(d => d.time > cutoff);
            }
        };
        
        // ===== リアルタイム指標更新 =====
        function updateLiveMetrics() {
            const now = performance.now();
            
            console.log('updateLiveMetrics:', {
                recentShots: tracker.recentShots.length,
                recentDanger: tracker.recentDanger.length,
                now: now,
                windowMs: tracker.windowMs,
                shotsData: tracker.recentShots.slice(0, 3) // 最初の3件を表示
            });
            
            // ① 攻撃テンポ (shots/sec in last 3 seconds)
            const shotCount = tracker.recentShots.length;
            const shotsPerSec = shotCount / 3;
            const attackPercent = Math.min(100, (shotsPerSec / 4) * 100); // 4shots/sec = 100%
            document.getElementById('attackBar').style.width = attackPercent + '%';
            document.getElementById('attackValue').textContent = shotsPerSec.toFixed(1);
            
            console.log('Attack:', shotsPerSec.toFixed(1), 'shots/sec', 'shotCount:', shotCount);
            
            // ② 危険滞在率 (danger time / 3 seconds)
            const totalDanger = tracker.recentDanger.reduce((sum, d) => sum + d.danger, 0);
            const dangerPercent = (totalDanger / tracker.windowMs) * 100;
            const dangerBar = document.getElementById('dangerBar');
            dangerBar.style.width = Math.min(100, dangerPercent) + '%';
            document.getElementById('dangerValue').textContent = Math.round(dangerPercent) + '%';
            
            console.log('Danger:', Math.round(dangerPercent) + '%');
            
            // 色変化
            dangerBar.className = 'metric-fill';
            if (dangerPercent < 30) {
                dangerBar.classList.add('danger-low');
            } else if (dangerPercent < 60) {
                dangerBar.classList.add('danger-medium');
            } else {
                dangerBar.classList.add('danger-high');
            }
            
            // ③ 精密度 (hits / shots in last 5 shots or 3 seconds)
            if (shotCount >= 3) {
                const recentHits = tracker.recentShots.filter(s => s.hit).length;
                const precisionPercent = (recentHits / shotCount) * 100;
                document.getElementById('precisionBar').style.width = precisionPercent + '%';
                document.getElementById('precisionValue').textContent = Math.round(precisionPercent) + '%';
                console.log('Precision:', Math.round(precisionPercent) + '%', 'hits:', recentHits, 'shots:', shotCount);
            } else {
                document.getElementById('precisionBar').style.width = '0%';
                document.getElementById('precisionValue').textContent = '--';
            }
        }
        
        // ===== 正規化 =====
        function clamp01(x) { return Math.max(0, Math.min(1, x)); }
        function norm(x, min, max) {
            if (max <= min) return 0;
            return clamp01((x - min) / (max - min));
        }
        
        // ===== 分析 =====
        function analyzePlay(tr) {
            const playTimeMs = Math.max(1, tr.tEnd - tr.tStart);
            const playTime = playTimeMs / 1000;
            const stable = playTime >= 3;
            
            const aggressionRaw = tr.shots / playTime;
            const accuracyRaw = tr.hits / Math.max(1, tr.shots);
            const efficiencyRaw = tr.kills / Math.max(1, tr.shots);
            const mobilityRaw = tr.moveDist / playTime;
            const riskRaw = (tr.dangerTime / playTimeMs);
            const fixationRaw = 1 - (tr.turns / Math.max(1, tr.moveDist / 10));
            const resilienceRaw = (tr.postHitShots / Math.max(1, tr.shots)) * 4;
            
            const aggression = stable ? norm(aggressionRaw, 0.5, 6.0) : 0.5;
            const accuracy   = stable ? clamp01(accuracyRaw) : 0.5;
            const efficiency = stable ? clamp01(efficiencyRaw) : 0.5;
            const mobility   = stable ? norm(mobilityRaw, 20, 220) : 0.5;
            const risk       = stable ? clamp01(riskRaw) : 0.5;
            const fixation   = stable ? clamp01(fixationRaw) : 0.5;
            const resilience = stable ? clamp01(resilienceRaw) : 0.5;
            
            const metrics = { playTime, aggression, accuracy, efficiency, mobility, risk, fixation, resilience };
            
            // ミニ称号
            const minis = [];
            minis.push(aggression >= 0.6 ? "《連射の求道者》" : "《静観する狙撃手》");
            minis.push(mobility   >= 0.6 ? "《流動回避者》"   : "《定点制圧者》");
            minis.push(risk       >= 0.6 ? "《危険域常駐型》" : "《安全圏設計士》");
            minis.push(accuracy   >= 0.6 ? "《精密照準士》"   : "《弾幕実験者》");
            minis.push(fixation   >= 0.6 ? "《手順固定者》"   : "《即興適応者》");
            
            // メイン称号
            const types = [
                {
                    key: "front_processor",
                    title: "《前線演算機》",
                    tagline: "危険域で計算を回し続ける侵略者。",
                    score: (m) => 0.35*m.risk + 0.25*m.aggression + 0.20*m.efficiency + 0.20*m.resilience
                },
                {
                    key: "silent_dominator",
                    title: "《静止する支配者》",
                    tagline: "最小の動きで最大の結果を出す。",
                    score: (m) => 0.35*(1-m.mobility) + 0.30*m.accuracy + 0.25*m.efficiency + 0.10*m.fixation
                },
                {
                    key: "flow_survivor",
                    title: "《流動生存体》",
                    tagline: "止まらないことで生き残る。",
                    score: (m) => 0.45*m.mobility + 0.25*(1-m.risk) + 0.20*m.resilience + 0.10*(1-m.fixation)
                },
                {
                    key: "pattern_architect",
                    title: "《手順建築士》",
                    tagline: "勝ち筋を固定して現実にする。",
                    score: (m) => 0.40*m.fixation + 0.25*m.efficiency + 0.20*(1-m.mobility) + 0.15*(1-m.risk)
                },
                {
                    key: "barrage_engineer",
                    title: "《弾幕工兵》",
                    tagline: "試行回数で正解を掘り当てる。",
                    score: (m) => 0.45*m.aggression + 0.20*(1-m.accuracy) + 0.20*m.resilience + 0.15*m.mobility
                },
                {
                    key: "precision_surgeon",
                    title: "《精密外科医》",
                    tagline: "撃つのは必要な時だけ。",
                    score: (m) => 0.50*m.accuracy + 0.30*m.efficiency + 0.20*(1-m.aggression)
                },
                {
                    key: "adaptive_optimizer",
                    title: "《場当たり最適化者》",
                    tagline: "その瞬間が常に正解になる。",
                    score: (m) => 0.35*(1-m.fixation) + 0.25*m.mobility + 0.25*m.resilience + 0.15*m.efficiency
                },
                {
                    key: "safe_margin_designer",
                    title: "《安全余白設計者》",
                    tagline: "負けない戦場を作る。",
                    score: (m) => 0.50*(1-m.risk) + 0.25*m.fixation + 0.15*m.efficiency + 0.10*m.accuracy
                }
            ];
            
            let best = types[0];
            let bestScore = -Infinity;
            for (const t of types) {
                const s = t.score(metrics);
                if (s > bestScore) { bestScore = s; best = t; }
            }
            
            // レア称号
            let rare = null;
            if (stable && tr.lifeLost === 0 && metrics.accuracy >= 0.7 && metrics.risk <= 0.35) {
                rare = { title: "《無傷の審判者》", tagline: "一度も崩れずに侵略を裁いた。" };
            } else if (stable && metrics.aggression >= 0.75 && metrics.mobility >= 0.7 && metrics.risk >= 0.6) {
                rare = { title: "《暴風侵略者》", tagline: "弾と移動で世界を塗り替えた。" };
            }
            
            // コメント生成
            const comments = [];
            comments.push(best.tagline);
            
            const feats = [];
            feats.push(metrics.accuracy >= 0.65 ? "命中効率が高い。狙う価値がある時だけ撃ててる。" : "弾数で道を作るタイプ。試行回数が武器になってる。");
            feats.push(metrics.mobility >= 0.65 ? "左右移動が多く、回避で生存率を上げる設計になってる。" : "位置を固定して制圧する傾向。照準と間合いで勝ってる。");
            feats.push(metrics.risk >= 0.6 ? "危険帯に長く滞在してでも成果を取りに行く。" : "安全余白を保って、事故率を落とす動きが多い。");
            
            comments.push(feats[0]);
            comments.push(feats[1]);
            
            if (metrics.risk >= 0.7 && tr.lifeLost >= 2) {
                comments.push("攻めの滞在時間が長め。シールドの残りを'撤退の合図'にすると安定する。");
            } else if (metrics.aggression <= 0.35 && tr.kills <= 2) {
                comments.push("攻撃回数が少なめ。『迷ったら1発』のルールを入れると伸びる。");
            } else {
                comments.push("今の戦い方は完成度が高い。次は'1つだけ癖を変える'と伸びが見える。");
            }
            
            return {
                metrics,
                minis,
                mainTitle: best.title,
                mainTagline: best.tagline,
                rareTitle: rare?.title ?? null,
                rareTagline: rare?.tagline ?? null,
                comments
            };
        }
        
        // 危険判定
        function calcDangerFlag(player, enemyBullets) {
            for (const b of enemyBullets) {
                const nearY = (b.y >= player.y - 80 && b.y <= player.y);
                const nearX = Math.abs(b.x - player.x) <= 40;
                if (nearY && nearX) return true;
            }
            return false;
        }
        
        function playSound(type) {
            if (!audioContext) return;
            
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            switch(type) {
                case 'shoot':
                    oscillator.type = 'square';
                    oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.1);
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                    break;
                case 'invaderShoot':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(200, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(100, audioContext.currentTime + 0.15);
                    gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.15);
                    break;
                case 'explosion':
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.setValueAtTime(150, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.2);
                    gainNode.gain.setValueAtTime(0.4, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                    break;
                case 'hit':
                    oscillator.type = 'triangle';
                    oscillator.frequency.setValueAtTime(300, audioContext.currentTime);
                    oscillator.frequency.exponentialRampToValueAtTime(50, audioContext.currentTime + 0.3);
                    gainNode.gain.setValueAtTime(0.5, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.3);
                    break;
            }
        }
        
        let canvasWidth, canvasHeight;
        
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvasWidth = container.clientWidth;
            canvasHeight = container.clientHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        if (!canvasWidth || !canvasHeight) {
            resizeCanvas();
        }
        
        let gameState = {
            score: 0,
            hiScore: parseInt(localStorage.getItem('invadersHiScore')) || 0,
            lives: 3,
            level: 1,
            gameRunning: false,
            gameOver: false
        };
        
        class Player {
            constructor() {
                this.width = 40;
                this.height = 25;
                this.x = canvasWidth / 2 - this.width / 2;
                this.y = canvasHeight - 60;
                this.speed = (canvasWidth && canvasWidth < 600) ? 6 : 5;
                this.color = '#00ff00';
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x + 15, this.y + 15, 10, 10);
                ctx.fillRect(this.x, this.y + 20, this.width, 5);
                ctx.fillRect(this.x + 17, this.y + 5, 6, 10);
                ctx.shadowBlur = 0;
            }
            
            moveLeft() {
                this.x = Math.max(0, this.x - this.speed);
            }
            
            moveRight() {
                this.x = Math.min(canvasWidth - this.width, this.x + this.speed);
            }
        }
        
        class Bullet {
            constructor(x, y, isPlayer = true) {
                this.x = x;
                this.y = y;
                this.width = 3;
                this.height = 10;
                const isMobile = canvasWidth && canvasWidth < 600;
                this.speed = isPlayer ? (isMobile ? -9 : -7) : (isMobile ? 3 : 4);
                this.isPlayer = isPlayer;
                this.color = isPlayer ? '#00ff00' : '#ff0000';
            }
            
            update() {
                this.y += this.speed;
            }
            
            draw() {
                ctx.fillStyle = this.color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
                ctx.shadowBlur = 0;
            }
            
            isOffScreen() {
                return this.y < 0 || this.y > canvasHeight;
            }
        }
        
        class Invader {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.width = 30;
                this.height = 25;
                this.type = type;
                this.alive = true;
                this.points = (3 - type) * 10 + 10;
            }
            
            draw() {
                if (!this.alive) return;
                
                ctx.fillStyle = '#00ff00';
                ctx.shadowBlur = 8;
                ctx.shadowColor = '#00ff00';
                
                const frame = Math.floor(Date.now() / 500) % 2;
                const offset = frame * 3;
                
                if (this.type === 0) {
                    ctx.fillRect(this.x + 8, this.y, 14, 5);
                    ctx.fillRect(this.x + 5, this.y + 5, 20, 10);
                    ctx.fillRect(this.x + offset, this.y + 15, 5, 5);
                    ctx.fillRect(this.x + 12, this.y + 15, 5, 5);
                    ctx.fillRect(this.x + 23 - offset, this.y + 15, 5, 5);
                } else if (this.type === 1) {
                    ctx.fillRect(this.x + 5, this.y + 5, 20, 10);
                    ctx.fillRect(this.x + offset, this.y, 5, 5);
                    ctx.fillRect(this.x + 23 - offset, this.y, 5, 5);
                    ctx.fillRect(this.x + offset, this.y + 15, 8, 5);
                    ctx.fillRect(this.x + 20 - offset, this.y + 15, 8, 5);
                } else {
                    ctx.fillRect(this.x + 10, this.y, 10, 5);
                    ctx.fillRect(this.x + 5, this.y + 5, 20, 10);
                    ctx.fillRect(this.x + 5 + offset, this.y + 15, 5, 5);
                    ctx.fillRect(this.x + 20 - offset, this.y + 15, 5, 5);
                }
                
                ctx.shadowBlur = 0;
            }
        }
        
        class Shield {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 60;
                this.height = 40;
                this.damage = Array(4).fill(null).map(() => Array(6).fill(true));
            }
            
            draw() {
                ctx.fillStyle = '#00ff00';
                const blockW = this.width / 6;
                const blockH = this.height / 4;
                
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 6; col++) {
                        if (this.damage[row][col]) {
                            if ((row === 0 && (col === 0 || col === 5)) || 
                                (row === 3 && (col === 2 || col === 3))) {
                                continue;
                            }
                            ctx.fillRect(this.x + col * blockW, this.y + row * blockH, blockW - 1, blockH - 1);
                        }
                    }
                }
            }
            
            checkHit(bullet) {
                if (bullet.x >= this.x && bullet.x <= this.x + this.width &&
                    bullet.y >= this.y && bullet.y <= this.y + this.height) {
                    const col = Math.floor((bullet.x - this.x) / (this.width / 6));
                    const row = Math.floor((bullet.y - this.y) / (this.height / 4));
                    
                    if (row >= 0 && row < 4 && col >= 0 && col < 6) {
                        this.damage[row][col] = false;
                        if (Math.random() > 0.5 && col > 0) this.damage[row][col - 1] = false;
                        if (Math.random() > 0.5 && col < 5) this.damage[row][col + 1] = false;
                        return true;
                    }
                }
                return false;
            }
        }
        
        let player;
        let invaders = [];
        let bullets = [];
        let shields = [];
        let invaderDirection = 1;
        let invaderSpeed = 1;
        let lastShot = 0;
        let lastInvaderShot = 0;
        let lastFrameTime = 0;
        
        const keys = { left: false, right: false, space: false };
        
        function init() {
            const isMobile = canvasWidth < 600;
            
            player = new Player();
            bullets = [];
            invaders = [];
            shields = [];
            invaderDirection = 1;
            invaderSpeed = isMobile ? 0.5 + (gameState.level - 1) * 0.2 : 1 + (gameState.level - 1) * 0.3;
            
            const rows = 5;
            const cols = isMobile ? 8 : 11;
            const startX = isMobile ? 20 : 50;
            const startY = isMobile ? 30 : 50;
            const spacingX = isMobile ? Math.floor((canvasWidth - 40) / cols) : 45;
            const spacingY = isMobile ? 30 : 40;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const type = row < 1 ? 0 : row < 3 ? 1 : 2;
                    invaders.push(new Invader(startX + col * spacingX, startY + row * spacingY, type));
                }
            }
            
            const shieldY = isMobile ? canvasHeight - 180 : canvasHeight - 150;
            const shieldCount = isMobile ? 3 : 4;
            const shieldSpacing = canvasWidth / (shieldCount + 1);
            for (let i = 0; i < shieldCount; i++) {
                shields.push(new Shield(shieldSpacing * (i + 1) - 30, shieldY));
            }
            
            updateLives();
            updateScore();
        }
        
        function updateLives() {
            livesContainer.innerHTML = '';
            for (let i = 0; i < gameState.lives; i++) {
                const life = document.createElement('div');
                life.className = 'life-icon';
                livesContainer.appendChild(life);
            }
        }
        
        function updateScore() {
            scoreEl.textContent = gameState.score.toString().padStart(4, '0');
            hiScoreEl.textContent = gameState.hiScore.toString().padStart(4, '0');
        }
        
        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }
        
        function gameLoop(currentTime) {
            if (!gameState.gameRunning) return;
            
            const dtMs = lastFrameTime ? currentTime - lastFrameTime : 16;
            lastFrameTime = currentTime;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // プレイヤー移動
            if (keys.left) player.moveLeft();
            if (keys.right) player.moveRight();
            
            // 危険判定
            const enemyBullets = bullets.filter(b => !b.isPlayer);
            const dangerFlag = calcDangerFlag(player, enemyBullets);
            
            // トラッカー更新
            tracker.update(currentTime, dtMs, player.x, dangerFlag);
            
            // プレイヤー射撃
            const shotCooldown = canvasWidth < 600 ? 350 : 500;
            if (keys.space && Date.now() - lastShot > shotCooldown) {
                const now = performance.now(); // 修正: performance.nowに統一
                bullets.push(new Bullet(player.x + player.width / 2, player.y, true));
                playSound('shoot');
                tracker.onShoot(now, false); // hitはあとで判定
                lastShot = Date.now();
            }
            
            // インベーダー移動
            let moveDown = false;
            const aliveInvaders = invaders.filter(inv => inv.alive);
            
            if (aliveInvaders.length > 0) {
                const leftmost = Math.min(...aliveInvaders.map(inv => inv.x));
                const rightmost = Math.max(...aliveInvaders.map(inv => inv.x + inv.width));
                
                if ((invaderDirection > 0 && rightmost >= canvasWidth - 10) ||
                    (invaderDirection < 0 && leftmost <= 10)) {
                    moveDown = true;
                    invaderDirection *= -1;
                }
            }
            
            invaders.forEach(invader => {
                if (invader.alive) {
                    if (moveDown) {
                        const dropDistance = canvasWidth < 600 ? 10 : 20;
                        invader.y += dropDistance;
                    } else {
                        invader.x += invaderDirection * invaderSpeed;
                    }
                    invader.draw();
                    
                    const dangerZone = canvasWidth < 600 ? player.y - 20 : player.y;
                    if (invader.y + invader.height >= dangerZone) {
                        gameState.lives = 0;
                        endGame();
                    }
                }
            });
            
            // インベーダー射撃
            const shotInterval = canvasWidth < 600 ? 1500 : 1000;
            if (Date.now() - lastInvaderShot > shotInterval && aliveInvaders.length > 0) {
                const shooter = aliveInvaders[Math.floor(Math.random() * aliveInvaders.length)];
                bullets.push(new Bullet(shooter.x + shooter.width / 2, shooter.y + shooter.height, false));
                playSound('invaderShoot');
                lastInvaderShot = Date.now();
            }
            
            // 弾の更新
            bullets = bullets.filter(bullet => {
                bullet.update();
                bullet.draw();
                
                if (bullet.isOffScreen()) return false;
                
                for (let shield of shields) {
                    if (shield.checkHit(bullet)) return false;
                }
                
                if (bullet.isPlayer) {
                    for (let invader of invaders) {
                        if (invader.alive && checkCollision(bullet, invader)) {
                            invader.alive = false;
                            playSound('explosion');
                            tracker.onHitEnemy();
                            tracker.onKillEnemy();
                            
                            // 直近の射撃をhitとしてマーク
                            const recentShot = tracker.recentShots[tracker.recentShots.length - 1];
                            if (recentShot && currentTime - recentShot.time < 1000) {
                                recentShot.hit = true;
                            }
                            
                            gameState.score += invader.points;
                            updateScore();
                            
                            if (gameState.score > gameState.hiScore) {
                                gameState.hiScore = gameState.score;
                                localStorage.setItem('invadersHiScore', gameState.hiScore);
                            }
                            
                            return false;
                        }
                    }
                } else {
                    if (checkCollision(bullet, player)) {
                        playSound('hit');
                        gameState.lives--;
                        updateLives();
                        tracker.onLifeLost(performance.now()); // 修正
                        
                        if (gameState.lives <= 0) {
                            endGame();
                        } else {
                            player.x = canvasWidth / 2 - player.width / 2;
                        }
                        return false;
                    }
                }
                
                return true;
            });
            
            shields.forEach(shield => shield.draw());
            player.draw();
            
            if (invaders.every(inv => !inv.alive)) {
                gameState.level++;
                init();
            }
            
            // リアルタイム指標更新（毎フレーム呼ぶ - テスト用）
            updateLiveMetrics();
            
            requestAnimationFrame(gameLoop);
        }
        
        function startGame() {
            console.log('startGame called');
            initAudio();
            
            gameState.score = 0;
            gameState.lives = 3;
            gameState.level = 1;
            gameState.gameRunning = true;
            gameState.gameOver = false;
            lastFrameTime = 0;
            
            console.log('Canvas size:', canvasWidth, canvasHeight);
            
            // トラッカー初期化
            Object.assign(tracker, {
                tStart: 0, tEnd: 0, shots: 0, hits: 0, kills: 0,
                moveDist: 0, turns: 0, dangerTime: 0, lifeLost: 0,
                lastHitAt: -Infinity, postHitWindowMs: 2500,
                postHitShots: 0, postHitMove: 0,
                lastX: null, lastMoveDir: 0,
                recentShots: [], recentDanger: [], windowMs: 3000
            });
            
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            document.getElementById('liveMetrics').classList.add('active');
            
            console.log('Calling init()');
            init();
            console.log('Player created at:', player.x);
            tracker.start(performance.now(), player.x);
            console.log('Starting game loop');
            requestAnimationFrame(gameLoop);
        }
        
        function endGame() {
            gameState.gameRunning = false;
            gameState.gameOver = true;
            
            document.getElementById('liveMetrics').classList.remove('active');
            
            tracker.end(performance.now());
            const result = analyzePlay(tracker);
            
            finalScoreEl.textContent = gameState.score.toString().padStart(4, '0');
            
            // 結果表示
            let html = '';
            
            if (result.rareTitle) {
                html += `<div class="rare-title">${result.rareTitle}</div>`;
                html += `<div class="tagline">${result.rareTagline}</div>`;
            }
            
            html += `<div class="main-title">${result.mainTitle}</div>`;
            html += `<div class="tagline">${result.mainTagline}</div>`;
            
            html += `<div class="mini-titles">`;
            result.minis.slice(0, 3).forEach(m => {
                html += `${m}<br>`;
            });
            html += `</div>`;
            
            html += `<div class="comments">`;
            result.comments.forEach(c => {
                html += `${c}<br><br>`;
            });
            html += `</div>`;
            
            html += `<div class="metrics">`;
            html += `[詳細指標]<br>`;
            html += `攻撃密度: ${(result.metrics.aggression * 100).toFixed(0)}% | `;
            html += `精密度: ${(result.metrics.accuracy * 100).toFixed(0)}%<br>`;
            html += `機動性: ${(result.metrics.mobility * 100).toFixed(0)}% | `;
            html += `リスク: ${(result.metrics.risk * 100).toFixed(0)}%<br>`;
            html += `固着度: ${(result.metrics.fixation * 100).toFixed(0)}% | `;
            html += `レジリエンス: ${(result.metrics.resilience * 100).toFixed(0)}%<br>`;
            html += `<br>総射撃: ${tracker.shots} | 命中: ${tracker.hits} | 撃破: ${tracker.kills}<br>`;
            html += `プレイ時間: ${result.metrics.playTime.toFixed(1)}秒`;
            html += `</div>`;
            
            resultContainer.innerHTML = html;
            gameOverScreen.classList.remove('hidden');
        }
        
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') keys.left = true;
            if (e.key === 'ArrowRight') keys.right = true;
            if (e.key === ' ') { e.preventDefault(); keys.space = true; }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') keys.left = false;
            if (e.key === 'ArrowRight') keys.right = false;
            if (e.key === ' ') keys.space = false;
        });
        
        startButton.addEventListener('click', startGame);
        retryButton.addEventListener('click', startGame);
        
        const leftBtn = document.getElementById('leftBtn');
        const rightBtn = document.getElementById('rightBtn');
        const fireBtn = document.getElementById('fireBtn');
        
        leftBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.left = true; });
        leftBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys.left = false; });
        rightBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.right = true; });
        rightBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys.right = false; });
        fireBtn.addEventListener('touchstart', (e) => { e.preventDefault(); keys.space = true; });
        fireBtn.addEventListener('touchend', (e) => { e.preventDefault(); keys.space = false; });
        
        leftBtn.addEventListener('mousedown', () => keys.left = true);
        leftBtn.addEventListener('mouseup', () => keys.left = false);
        leftBtn.addEventListener('mouseleave', () => keys.left = false);
        rightBtn.addEventListener('mousedown', () => keys.right = true);
        rightBtn.addEventListener('mouseup', () => keys.right = false);
        rightBtn.addEventListener('mouseleave', () => keys.right = false);
        fireBtn.addEventListener('mousedown', () => keys.space = true);
        fireBtn.addEventListener('mouseup', () => keys.space = false);
        fireBtn.addEventListener('mouseleave', () => keys.space = false);
        
        updateScore();
        updateLives();
    </script>
</body>
</html>
